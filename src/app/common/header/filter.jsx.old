import React, { Component } from 'react'
import { withRouter, NavLink, Link } from 'react-router-dom'
import { isMobile } from 'react-device-detect'
import URI from 'urijs'
import { connect } from 'react-redux'
import Select from './../../forms/select.jsx'
import { DATE_PATHS, DEFAULT_SELECT_SETTINGS } from './../../constants.jsx'
import { IconClose } from './../icons.jsx'
import store from './../../redux/store.jsx'
import User from './../../authentication/models/user.jsx'
import UserActions from './../../redux/actions/user.jsx'
import * as AppActions from './../../redux/actions/app.jsx'
import { getDateRange, getDateName, getOptionByValue } from './../../helpers'
import { track } from './../../helpers/analytics.jsx'
import Carousel from './../carousel.jsx'

//
// FILTER OPTIONS
//
const OPTIONS_SCENE = [
	{ value: 'all', label: 'All Scenes' }
]

const OPTIONS_VENUE = [
	{ value: 'all', label: 'All Venues' }
]

const OPTIONS_SORT = [
	{ value: 'all', label: 'All Shows' },
	{ value: 'best', label: 'Best Shows' }
	// { value: 'rad', label: 'Rad Shows' }
]

const OPTIONS_DATE = [
	{ value: 'all', label: 'All Dates' },
	{ value: 'weekend', label: 'This Weekend' },
	{ value: 'next-weekend', label: 'Next Weekend' },
	{ value: 'next-week', label: 'Next Week' }
]

const OPTIONS_COST = [
	{ value: 'all', label: 'All Prices' },
	{ value: 'free', label: 'Free' },
	{ value: 'under-15', label: 'Under $15' },
	{ value: '15-and-over', label: '$15 and Over' }
]


//
// DEFAULTS
//
const DEFAULT_FILTERS = {
	sort: getOptionByValue(OPTIONS_SORT, User.getSort()),
	venue: getOptionByValue(OPTIONS_VENUE, 'all'),
	date: getOptionByValue(OPTIONS_DATE, 'all'),
	cost: getOptionByValue(OPTIONS_COST, 'all')
}

//
// Component
//
class Filter extends Component {
	constructor(props) {
		super(props)

		this.state = DEFAULT_FILTERS

		this._resetHome = this._resetHome.bind(this)
		this._setToggleFocus = this._setToggleFocus.bind(this)
		this._setDateRange = this._setDateRange.bind(this)
		this._getVenues = this._getVenues.bind(this)
		this._setVenue = this._setVenue.bind(this)
		this._setSort = this._setSort.bind(this)
		this._setCost = this._setCost.bind(this)
	}

	componentWillMount() {
		this.props.fetchVenues()
		this._resetFilter()
	}

	componentWillReceiveProps(nextProps) {
		let {
			searchSort,
			fetchVenues,
			resetSearch,
			venues,
			user
		} = nextProps

		if (searchSort !== this.state.sort) {
			this.setState({ sort: getOptionByValue(OPTIONS_SORT, searchSort) })
		}

		if (resetSearch !== this.props.resetSearch) {
			this._resetFilter()
		}
	}

	shouldComponentUpdate(nextProps, nextState) {
		return (
			nextState.focus !== this.state.focus ||
			nextProps.resetSearch !== this.props.resetSearch ||
			nextProps.searchSort !== this.props.searchSort ||
			!_.isEqual(nextProps.venues, this.props.venues) ||
			!_.isEqual(nextProps.user, this.props.user) ||
			!_.isEqual(nextState.sort, this.state.sort) ||
			!_.isEqual(nextState.venue, this.state.venue) ||
			!_.isEqual(nextState.date, this.state.date) ||
			!_.isEqual(nextState.cost, this.state.cost)
		)
	}

	_search() {
		let searchButtonEl = document.querySelector('form#search [type="submit"]')

		if (searchButtonEl) {
			searchButtonEl.click()
		}
	}

	_resetHome() {
		this.setState(DEFAULT_FILTERS)
		this.props.resetHome()
	}

	_resetFilter = () => {
		let uri = new URI()
		let { user, history, searchSort, fetchVenues } = this.props
		let { pathname, search } = history.location
		let query = uri.setSearch(search).search(true)
		let dateName = query.from ? getDateName(decodeURIComponent(query.from)) : 'all'


		// Set defaults
		this._setSort(getOptionByValue(OPTIONS_SORT, User.getSort() || 'all'))
		// this.setState(
		// 	_.defaults({
		// 		sort: getOptionByValue(OPTIONS_SORT, User.getSort() || DEFAULT_FILTERS.sort.value)
		// 	}, DEFAULT_FILTERS)
		// )

		if (query.cost) {
			this.setState({
				cost: getOptionByValue(OPTIONS_COST, query.cost)
			})
		}

		if (query.from) {
			this.setState({
				date: getOptionByValue(
					OPTIONS_DATE,
					([ 'today', 'tomorrow' ].indexOf(dateName) >= 0) ? 'all' : dateName
				)
			})
		}

		if (query.venue) {
			this.setState({
				venue: {
					value: decodeURIComponent(query.venue),
					label: decodeURIComponent(query.venue)
				}
			})
		}

		if (DATE_PATHS.indexOf(pathname) >= 0) {
			switch(pathname) {
				case '/weekend':
					this.setState({ date: getOptionByValue(OPTIONS_DATE, 'weekend') })
					break
				case '/next-weekend':
					this.setState({ date: getOptionByValue(OPTIONS_DATE, 'next-weekend') })
					break
				case '/next-week':
					this.setState({ date: getOptionByValue(OPTIONS_DATE, 'next-week') })
					break
			}

			this.props.setSearchDateRange(getDateRange(pathname))
		}
	}

	_setSort(evt) {
		let { value, label } = evt
		let { user, searchSort, setSearchSort, clearSearch } = this.props
		let { pathname } = this.props.history.location

		if (_.isEqual(evt, this.state.sort)) {
			return
		}

		this.setState({ sort: evt })

		// Save sort option
		if (user) {
			User.setSort(value)
		}

		clearSearch()
		setSearchSort(value)

		track('filter', {
			action: value,
			label: value,
			filter: value
		})
	}

	_setVenue(evt) {
		let { value, label } = evt
		let { setSearchVenue } = this.props
		let venues = this._getVenues()
		let venueNames = _.pluck(venues, 'value')

		if (_.isEqual(evt, this.state.venue)) {
			return
		}

		this.setState({ venue: evt })
		setSearchVenue((value === 'all') ? '' : value)

		track('filter', {
			action: value,
			label: value,
			filter: value
		})
	}

	_setCost(evt) {
		let { value, label } = evt
		let { setSearchCost } = this.props

		if (_.isEqual(evt, this.state.cost)) {
			return
		}

		this.setState({ cost: evt })

		setSearchCost(value === 'all' ? '' : value)

		track('filter', {
			action: value,
			label: value,
			filter: value
		})
	}

	_setDateRange(evt) {
		let { value, label } = evt
		let { setSearchDateRange } = this.props

		if (_.isEqual(evt, this.state.date)) {
			return
		}

		this.setState({ date: evt })

		setSearchDateRange(getDateRange(value))

		track('filter', {
			action: value,
			label: value,
			filter: value
		})
	}

	_setToggleFocus(focus) {
		this.setState({ focus })
	}

	_getVenues() {
		let { user, venues } = this.props
		let _venues = []

		if (venues && venues.length > 0) {
			venues.forEach((venue, index) => {
				if (!_.where(_venues, { value: venue.name }).length) {
					_venues.push({
						value: venue.name, // TODO: this should be an ID
						label: venue.name
					})
				}
			})
		}

		_venues = _.union(OPTIONS_VENUE, _venues)

		return _venues
	}

	render() {
		let {
			user,
			history,
			viewportName,

			searchSort,
			searchQuery,
			searchLocation,
			searchDateTo,
			searchCost,
			searchTag
		} = this.props

		let { focus } = this.state

		let { pathname, search } = history.location
		let isSearching = (searchQuery || searchLocation || searchDateTo || searchCost || searchTag)
		let venues = this._getVenues()
		let classColumn = user ? 'col-7-of-12 col-medium-10-of-12' : 'col-6-of-12 col-medium-8-of-12'

		return (
			<div className="header-filter">
				<div className="row">
					<div className={`col ${classColumn} col-small-12-of-12 center ${isSearching ? 'is-searching' : ''}`}>
						<div className={`filter-scroll ${focus ? 'filter--focus' : ''}`}>
							<ul>
								{user && (
									<li className="filter-sort">
										<Select
											type="simple"
											settings={{
												...DEFAULT_SELECT_SETTINGS,
												name: 'sort',
												value: this.state.sort,
												defaultValue: this.state.sort,
												onChange: this._setSort,
												onFocus: this._setToggleFocus.bind(this, true),
												onBlur: this._setToggleFocus.bind(this, false),
												menuShouldScrollIntoView: false
											}}
											options={OPTIONS_SORT} />
									</li>
								)}

								{/*{user && (
									<li className="filter-location small-hide">
										<Select
											type="simple"
											settings={{
												...DEFAULT_SELECT_SETTINGS,
												name: 'location',
												value: scenes[0],
												defaultValue: scenes[0],
												onChange: this._setScene,
												onFocus: this._setToggleFocus.bind(this, true),
												onBlur: this._setToggleFocus.bind(this, false)
											}}
											options={scenes} />
									</li>
								)}*/}

								<li className="filter-venue">
									<Select
										type="simple"
										settings={{
											...DEFAULT_SELECT_SETTINGS,
											name: 'venue',
											value: this.state.venue,
											defaultValue: venues[0],
											onChange: this._setVenue,
											onFocus: this._setToggleFocus.bind(this, true),
											onBlur: this._setToggleFocus.bind(this, false)
										}}
										options={venues} />
								</li>

								<li className="filter-date">
									<Select
										type="simple"
										settings={{
											...DEFAULT_SELECT_SETTINGS,
											name: 'date',
											value: this.state.date,
											defaultValue: this.state.date,
											onChange: this._setDateRange,
											onFocus: this._setToggleFocus.bind(this, true),
											onBlur: this._setToggleFocus.bind(this, false)
										}}
										options={OPTIONS_DATE} />
								</li>
								<li className="filter-cost">
									<Select
										type="simple"
										settings={{
											...DEFAULT_SELECT_SETTINGS,
											name: 'cost',
											value: this.state.cost,
											defaultValue: this.state.cost,
											onChange: this._setCost,
											onFocus: this._setToggleFocus.bind(this, true),
											onBlur: this._setToggleFocus.bind(this, false)
										}}
										options={OPTIONS_COST} />
								</li>

								{isSearching && (
									<li className="clear-control">
										<Link
											to="/"
											onClick={this._resetHome}
											className="btn btn-circlecompact background-accent-two"
											title="Clear search">
											<IconClose className="center-center" />
										</Link>
									</li>
								)}
							</ul>
						</div>
					</div>
				</div>
			</div>
		)
	}
}

const mapStateToProps = ({ app, user, shows }) => ({
	shows: shows.shows,
	showsSort: shows.showsSort,

	user: user.user,

	scenes: app.scenes,
	venues: app.venues,
	viewportName: app.viewportName,
	resetSearch: app.resetSearch,
	searchSort: app.searchSort,
	searchQuery: app.searchQuery,
	searchLocation: app.searchLocation,
	searchDateFrom: app.searchDateFrom,
	searchDateTo: app.searchDateTo,
	searchCost: app.searchCost,
	searchTag: app.searchTag
})

const mapDispatchToProps = dispatch => {
	return {
		loadStart: () => {
			dispatch(AppActions.loadStart())
		},

		loadEnd: () => {
			dispatch(AppActions.loadEnd())
		},

		resetHome: () => {
			dispatch(AppActions.resetHome())
		},

		clearSearch: () => {
			dispatch(AppActions.resetSearch())
		},

		fetchVenues: () => {
			dispatch(AppActions.apiFetchVenues())
		},

		setSearchQuery: (query) => {
			dispatch(AppActions.setSearchQuery(query))
		},

		setSearchSort: (sort = 'all') => {
			dispatch(AppActions.setSearchSort(sort))
		},

		setSearchLocation: (scene) => {
			dispatch(AppActions.setSearchLocation(scene))
		},

		setSearchVenue: (venue) => {
			dispatch(AppActions.setSearchVenue(venue))
		},

		setSearchDateRange: (range) => {
			dispatch(AppActions.setSearchDateRange(range))
		},

		setSearchCost: (cost) => {
			dispatch(AppActions.setSearchCost(cost))
		}
	}
}

export default withRouter(
	React.memo(connect(mapStateToProps, mapDispatchToProps)(Filter))
)
